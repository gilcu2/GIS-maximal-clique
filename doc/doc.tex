% Created 2013-11-12 Tue 20:00
\documentclass[12pt, a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel} 
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage[numbers]{natbib}
\usepackage{algorithm}
\usepackage{algpseudocode}
\author{Marek Lewandowski, Juliusz Gonera}
\date{}
\title{Porównanie algorytmów znajdowania maksymalnej kliki w grafie}
\begin{document}

\maketitle

\section{Problem maksymalnej kliki}
\label{sec-1}
Kliką nazywamy spójny podgraf, taki że nie jest on zawarty w żadnym innym spójnym podgrafie. Maksymalna klika to klika składająca się z największej liczby wierzchołków. Problem znajdowania maksymalnej kliki w grafie jest problemem NP-zupełnym.

\section{Algorytm}
\label{sec-2}
Do zaimplementowania został wybrany algorytm \ref{basicmc} przechodzący graf w głąb i używający techniki branch-and-bound w celu znalezienia maksymalnej kliki. Algorytm został opisany w \citep{bioinf} (Fig. 2). Zostanie on porównany z dostępną implementacją algorytmu Brona-Kerboscha w bibliotece JGraphT\citep{jgrapht}.

\subsection{Struktury danych}

W algorytmie \ref{basicmc} wykorzystywane są zbiory $Q$ i $Q_{max}$. $Q$ przechowuje wierzchołki aktualnie rozpatrywanej kliki. $Q_{max}$ zawiera wierzchołki największej kliki jaką dotąd udało się znaleźć. $R \subseteq V $ zawiera listę wierzchołków które mogą zostać dodane do $Q$.

\subsection{Opis Algorytmu}

Początkowo $Q := \emptyset, Q_{max} := \emptyset, R := V$. Wybieramy wierzchołek $p$ z dostępnych wierzchołków w $R$ i dodajemy go do $Q$ \algref{basicmc}{addPToQ}. Następnie obliczamy $R_{p} := R \cap \text{adj(}p\text{)}$ który staje się nowym zbiorem wierzchołków do przejrzenia. Procedura EXPAND() jest wywoływana rekursywnie do wyczerpania zbioru wierzchołków $R_{p}$. Jeśli $|Q|+|R| \leq |Q_{max}|$ to $Q \cup R$ może zawierać jedynie klikę niewiększą od $|Q_{max}|$, w tym przypadku algorytm pomija zbędne obliczenia.\algref{basicmc}{skip}

\subsection{Warunek Stopu}

W momencie osiągnięcia $R_{p} = \emptyset$, Zbiór $Q$ jest maksymalną kliką. Jeśli $|Q| \ge |Q_{max}|$ zbiór $Q$ zastępuje zbiór $Q_{max}$. Po usunięciu wierzchołka początkowego $p$ z $Q$ i $R$ wybieramy go z wierzchołków pozostałych w $R$ i powtarzamy do przejrzenia wszystkich wierzchołków ($R = \emptyset$)

\subsection{Złożoność Obliczeniowa}

\subsection{Sytuacje Awaryjne}

\begin{algorithm}
\caption{BasicMC}\label{basicmc}
\begin{algorithmic}[1]
  
\Procedure{BasicMC}{$V,E$}
\State $Q\gets \emptyset$;
\State $Q_{max}\gets \emptyset$;
\State \Call{EXPAND}{V};
\EndProcedure
\Statex

\Procedure{expand}{$R$}
\While{$R \not= \emptyset$}
  \State $p\gets v\in R$
  \If{$|Q|+|R|\ge |Q_{max}|$}
    \State $Q \gets Q \cup {p}$\label{addPToQ}
    \State $R_p \gets R \cap adj(p)$
    \If{$R_p \not= \emptyset$}
      \State \Call{EXPAND}{$R_{P}$}
    \ElsIf{$|Q| \ge |Q_{max}|$}
      \State $Q_{max} \gets Q$
    \EndIf
    \State $Q \gets Q - {p}$
  \Else
    \textbf{ return}\label{skip}
  \EndIf
  \State $R \gets R - p$
\EndWhile
\EndProcedure

\end{algorithmic}
\end{algorithm}

\section{Program}
\label{sec-3}
Program zostanie zaimplementowany w języku Scala. Jest to statycznie typowany język działający na JVM, w pełni kompatybilny z językiem Java.

Program będzie plikiem wykonywalnym wczytującym reprezentację grafu ze standardowego wejścia i wypisującym żądane informacje na standardowe wyjście.

\subsection{Wejście Programu}

Wejściem programu są pliki tekstowe ASCII. Wejście zawiera $|E|+1$ linii nie licząc linii zawierających komentarzy. Pierwsza linijka nie będąca komentarzem jest postaci 
\begin{verbatim}
p col |V| |E|
\end{verbatim}
Gdzie $|V|$ i $|E|$ to odpowiednio liczba węzłów i krawędzi grafu. Następne $|E|$ linijek odpowiada $|E|$ krawędziom grafu. Krawędź $(v, w)$ zapisywana jest jako 
\begin{verbatim}
e W V
\end{verbatim}
i występuje tylko raz. Krawędź $(w, v)$ stanowi części reprezentacji tekstowej grafu. Opisany format jest podzbiorem formatu DIMACS opisanego w \cite{dimacs_format}

\subsection{Opcje Programu}

Program będzie posiadał opcję która pozwala zmienić algorytm wyszukiwania największej kliki w celu porównania obu algorytmów.

\begin{verbatim}
-j użyj gotowego algorytmu biblioteki JGraph
\end{verbatim}

Przykładowe wywołanie programu:

\begin{verbatim}
./prog < input.txt >> results.txt
./prog -j < input.txt >> results.txt
\end{verbatim}

\subsection{Wyjście Programu}

Wyjście programu jest postaci.

\begin{verbatim}
w(g) TIME
\end{verbatim}
Gdzie $\omega(g)$ to rozmiar największej znalezionej kliki a $\text{TIME}$ - czas wykonania algorytmu.


\section{Testy}
\label{sec-4}
Do testowania poprawności i empirycznego porównania wydajności algorytmów zostanie użyty DIMACS Benchmark Set\citep{dimacs}. Jest to zbiór nietrywialnych grafów dla których znana jest liczba wierzchołków tworzących maksymalną klikę w grafie.

\subsection{Projekt Testów}

\nocite{*}
\bibliographystyle{plainnat}
\bibliography{bibliography}
\end{document}
